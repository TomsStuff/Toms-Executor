-- Settings configuration
local Settings = {
    Speed = 5,
    SprintSpeed = 30,
    ToggleKey = Enum.KeyCode.X,
    SprintKey = Enum.KeyCode.LeftControl,
    
    ForwardKey = Enum.KeyCode.W,
    LeftKey = Enum.KeyCode.A,
    BackwardKey = Enum.KeyCode.S,
    RightKey = Enum.KeyCode.D,
    UpKey = Enum.KeyCode.E,
    DownKey = Enum.KeyCode.Q,
}

-- Setup UI
local Screen = Instance.new("ScreenGui", game.CoreGui)
local Distance = Instance.new("TextLabel", Screen)
Distance.BackgroundTransparency = 1
Distance.Size = UDim2.new(0, 100, 0, 50)
Distance.ZIndex = 2
Distance.Text = "0"
Distance.TextStrokeTransparency = 0.5
Distance.TextSize = 20
Distance.TextStrokeColor3 = Color3.fromRGB(33, 33, 33)
Distance.Font = Enum.Font.Gotham
Distance.TextColor3 = Color3.new(1, 1, 1)
Distance.TextXAlignment = Enum.TextXAlignment.Left
Distance.TextYAlignment = Enum.TextYAlignment.Top

-- Services
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

-- Variables
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Direction = Vector3.new(0, 0, 0)
local InterpolatedDir = Direction
local Tilt = 0
local InterpolatedTilt = Tilt
local Toggled = false
local Sprinting = false
local CameraPos = game.Workspace.CurrentCamera.CFrame.Position
local KeyStates = {}
local LastPos

-- Linear Interpolation function
local function Lerp(a, b, t)
    return a + (b - a) * t
end

-- Update player movement based on key presses
local function UpdateMovement()
    local newDirection = Vector3.new(0, 0, 0)
    if KeyStates[Settings.ForwardKey] then
        newDirection = newDirection - Vector3.new(0, 0, 1)
    end
    if KeyStates[Settings.BackwardKey] then
        newDirection = newDirection + Vector3.new(0, 0, 1)
    end
    if KeyStates[Settings.LeftKey] then
        newDirection = newDirection - Vector3.new(1, 0, 0)
    end
    if KeyStates[Settings.RightKey] then
        newDirection = newDirection + Vector3.new(1, 0, 0)
    end
    if KeyStates[Settings.UpKey] then
        newDirection = newDirection + Vector3.new(0, 1, 0)
    end
    if KeyStates[Settings.DownKey] then
        newDirection = newDirection - Vector3.new(0, 1, 0)
    end
    Direction = newDirection
end

-- Input handling
UserInputService.InputBegan:Connect(function(inputObject, gameProcessedEvent)
    if not gameProcessedEvent then
        if inputObject.KeyCode == Settings.ToggleKey then
            KeyStates[Settings.ToggleKey] = true
            Toggled = not Toggled
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                if Toggled then
                    LastPos = character.HumanoidRootPart.Position
                    character.Humanoid.PlatformStand = true
                else
                    LastPos = nil
                    character.Humanoid.PlatformStand = false
                end
            end
        elseif inputObject.KeyCode == Settings.SprintKey then
            KeyStates[Settings.SprintKey] = true
            Sprinting = true
        else
            KeyStates[inputObject.KeyCode] = true
        end
        UpdateMovement()
    end
end)

UserInputService.InputEnded:Connect(function(inputObject)
    if not inputObject.UserInputType == Enum.UserInputType.Keyboard then return end
    if inputObject.KeyCode == Settings.ToggleKey then
        KeyStates[Settings.ToggleKey] = false
    elseif inputObject.KeyCode == Settings.SprintKey then
        KeyStates[Settings.SprintKey] = false
        Sprinting = false
    else
        KeyStates[inputObject.KeyCode] = false
    end
    UpdateMovement()
end)

-- Update on RenderStepped
RunService.RenderStepped:Connect(function()
    local character = LocalPlayer.Character
    if Toggled and character and character:FindFirstChild("HumanoidRootPart") then
        for _, v in pairs(character:GetDescendants()) do
            if v:IsA("BasePart") then
                v.Velocity = Vector3.new(0, 0, 0)
            end
        end
        local RootPart = character.HumanoidRootPart
        if LastPos then
            local distance = (LastPos - RootPart.Position).Magnitude
            Distance.Text = math.floor(distance + 0.5)
            Distance.TextColor3 = distance >= 350 and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
        else
            Distance.TextColor3 = Color3.new(1, 1, 1)
            Distance.Text = "0"
        end
        InterpolatedDir = InterpolatedDir:Lerp((Direction * (Sprinting and Settings.SprintSpeed or Settings.Speed)), 0.2)
        InterpolatedTilt = Lerp(InterpolatedTilt, Tilt * (Sprinting and 2 or 1), Tilt == 0 and 0.2 or 0.1)
        RootPart.CFrame = RootPart.CFrame:Lerp(CFrame.new(RootPart.Position, RootPart.Position + Mouse.UnitRay.Direction) * CFrame.Angles(0, math.rad(0), 0) * CFrame.new(InterpolatedDir) * CFrame.Angles(math.rad(InterpolatedTilt), 0, 0), 0.2)
    else
        Distance.TextColor3 = Color3.new(1, 1, 1)
        Distance.Text = "0"
    end
end)
